<?php
// $Id:  $

/**
 * @file
 * Allows to import external Vocabularies in order to map them to Drupal data
 * structure.
 */

/**
 * Implements hook_menu().
 */
function evoc_menu() {
  $items['evoc/import'] = array(
    'title' => 'Import external RDF vocabulary',
    'description' => 'Import RDF terms of an external vocabulary.',
    'page callback' => 'evoc_import',
    'access arguments' => array('administer content types'),
    'file' => 'evoc.pages.inc',
  );

  return $items;
}

/*
 * Import function for the evoc module.
 */
function evoc_import_vocabulary($vocabulary_uri, $vocabulary_prefix) {
$fetched_terms = evoc_fetch_vocabulary($vocabulary_uri, $vocabulary_prefix);
//var_dump($fetched_terms);

// @todo convert me to D7
//  _evoc_save_rdf_terms($vocabulary_uri, $vocabulary_prefix, $fetched_terms);
}

/**
 * Fetches the classes and properties of an external RDF vocabulary.
 *
 * @param $vocabulary_uri
 *   The namespace of the vocabulary to be fetched. Note most of the time this
 *   URI should end with / or #, e.g. http://rdfs.org/sioc/ns#
 * @param $vocabulary_prefix
 *   Prefix used system-wide for referring to this namespace.
 * @param $vocabulary_location
 *   URL of the vocabulary if the vocabulary namespace does not dereference and
 *   is not available at the namespace. Optionnal.
 * @param $ignore_base_ns
 *   Set to TRUE if all the terms found in the vocabulary should be imported
 *   regardless of whether they belong to the namespace or not. Optionnal.
 * @return
 *   An array of fetched terms.
 */
function evoc_fetch_vocabulary($vocabulary_uri, $vocabulary_prefix, $vocabulary_location = NULL, $ignore_base_ns = FALSE) {
  global $rdf_namespaces;

// @todo convert from D6.
//  rdf_get_namespaces();

  // TODO make sure the URI is valid either finishing with / or #
  // TODO make sure the prefix and the terms are not containing any forbidden characters.

  // Uses the vocabulary namespace URI if no specific location is given.
  $vocabulary_location = $vocabulary_location ? $vocabulary_location : $vocabulary_uri;


//   if (!in_array($vocabulary_uri, $rdf_namespaces)) {
//     // Add momentarily the namespace in memory to be able to convert the URIs to QNames.
//     $rdf_namespaces[$vocabulary_prefix] = $vocabulary_uri;
//   }
//   if ($ns_uri && !in_array($ns_uri, $rdf_namespaces)) {
//     // Add momentarily the namespace in memory to be able to convert the URIs to QNames.
//     $rdf_namespaces[$vocabulary_prefix] = $ns_uri;
//   }

  // SPARQL queries are stored in an array.
  $term_queries = array();
  // Typical SPARQL queries to retrieve properties/classes, working for all major vocabularies...
//   $term_queries[] = array('type' => 'class',
//                      'query' => "
//   prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
//   prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
//   prefix owl: <http://www.w3.org/2002/07/owl#>
//   select *
//   from <$vocabulary_uri>
//   where {
//   {?class rdf:type owl:Class}
//   union
//   {?class rdf:type rdfs:Class}.
//   OPTIONAL {?class rdfs:label ?label}.
//   OPTIONAL {?class rdfs:subClassOf ?superclass}.
//   OPTIONAL {?class rdfs:comment ?comment}.
//   }
//   limit 1000
//   ");
  $term_queries[] = array('type' => 'property',
                     'query' => "
  prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
  prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
  prefix owl: <http://www.w3.org/2002/07/owl#>
  select *
  from <$vocabulary_uri>
  where {
  {?property rdf:type owl:DatatypeProperty}
  union
  {?property rdf:type owl:ObjectProperty}
  union
  {?property rdf:type rdf:Property.}.
  OPTIONAL {?property rdfs:label ?label}.
  OPTIONAL {?property rdfs:domain ?domain}.
  OPTIONAL {?property rdfs:range ?range}.
  OPTIONAL {?property rdfs:comment ?comment}.
  }
  limit 1000
  ");


  // Loop through all the various queries in order to extract as many classes and properties as possible.
  $fetched_terms = array();
  foreach ($term_queries as $query) {
    $endpoint = 'http://demo.openlinksw.com/sparql/';
    //$endpoint = 'http://www.sparql.org/sparql';
    //$endpoint = 'http://jena.hpl.hp.com:2020/sparql';

    $datasets = array($vocabulary_location);

    $sparql_res = rdfx_sparql_request($query['query'], $datasets);

echo "end of querying";
return;

    if (!is_array($sparql_res)) {
      drupal_set_message("The SPARQL endpoint <a href=\"$endpoint\">$endpoint</a> returned an error. Please check it and make sure it allows to load from URIs via FROM clauses.", $type = 'warning', $repeat = FALSE);
    }
    // Parse the SPARQL results and extract the relevant terms.
    foreach ($sparql_res as $res_term) {
      if (isset($res_term['class'])) {
        $type = 'class';
      }
      elseif (isset($res_term['property'])) {
        $type = 'property';
      };

      $term_qname = rdf_uri_to_qname($res_term[$type]->uri);
      $term_qname_parts = explode(':', $term_qname);
      $term_prefix = $term_qname_parts[0];

      $term = array();
      $term['id'] = $term_qname_parts[1];
      $term['type'] = $type;
      $term['label'] = !empty($res_term['label']->value) ? $res_term['label']->value : NULL;
      $term['comment'] = !empty($res_term['comment']->value) ? $res_term['comment']->value : NULL;
      switch ($type) {
        case 'class' :
          $term['superclass'] = !empty($res_term['superclass']->uri) ? rdf_uri_to_qname($res_term['superclass']->uri) : NULL;
          break;

        case 'property' :
          // Extract some information like domain and range.
          $term['rdf_domain'] = !empty($res_term['domain']->uri) ? rdf_uri_to_qname($res_term['domain']->uri) : NULL;
          $term['rdf_range'] = !empty($res_term['range']->uri) ? rdf_uri_to_qname($res_term['range']->uri) : NULL;
          break;

      }

      // We only import the terms with the specified prefix unless $ignore_base_ns is TRUE.
      if ($term_prefix == $vocabulary_prefix || $ignore_base_ns) {
        $fetched_terms[] = $term;
      }
    }

  }
  // @TODO Clean up the terms to import and remove any duplicate? SPARQL should have done that already.

  return $fetched_terms;
}
