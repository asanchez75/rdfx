<?php
// $Id:  $

/**
 * @file
 * Allows to import external Vocabularies in order to map them to Drupal data
 * structure.
 */

/**
 * Implements hook_menu().
 */
function evoc_menu() {
  $items['evoc/import'] = array(
    'title' => 'Import external RDF vocabulary',
    'description' => 'Import RDF terms of an external vocabulary.',
    'page callback' => 'evoc_import',
    'access arguments' => array('administer content types'),
    'file' => 'evoc.pages.inc',
  );

  return $items;
}

/*
 * Import function for the evoc module.
 */
function evoc_import_vocabulary($vocabulary_uri, $vocabulary_prefix) {
  // Fetch the defined terms and a list of the defined namespaces.
  $fetched_vocab = evoc_fetch_vocabulary($vocabulary_uri, $vocabulary_prefix);
  rdfx_save_terms($fetched_vocab, $vocabulary_uri, $vocabulary_prefix);
  
  // Refresh the static variable that holds the array of namespaces.
  drupal_static_reset('rdfx_get_namespaces');
  //_evoc_save_rdf_terms($vocabulary_uri, $vocabulary_prefix, $fetched_terms);
}

/**
 * Fetches the classes and properties of an external RDF vocabulary.
 *
 * @param $vocabulary_uri
 *   The namespace of the vocabulary to be fetched. Note most of the time this
 *   URI should end with / or #, e.g. http://rdfs.org/sioc/ns#
 * @param $vocabulary_prefix
 *   Prefix used system-wide for referring to this namespace.
 * @param $vocabulary_location
 *   URL of the vocabulary if the vocabulary namespace does not dereference and
 *   is not available at the namespace. Optionnal.
 * @return
 *   An array of fetched terms.
 */
function evoc_fetch_vocabulary($vocabulary_uri, $vocabulary_prefix, $vocabulary_location = NULL) {
  $vocabulary = array();
  
  $parser = ARC2::getRDFXMLParser();
  $parser->parse($vocabulary_uri, file_get_contents('http://localhost/rdf-contrib/evoc_test/vocabulary_rdf_xml'));
  //dpm($parser);
  
  // Uses the vocabulary namespace URI if no specific location is given.
  $vocabulary_location = $vocabulary_location ? $vocabulary_location : $vocabulary_uri;

  // SPARQL queries are stored in an array.
  // Typical SPARQL queries to retrieve properties/classes, working for all major vocabularies...
  /*$queries[] = array(
    'type' => 'class',
    'query' => "
      prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
      prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
      prefix owl: <http://www.w3.org/2002/07/owl#>
      select *
      from <$vocabulary_uri>
      where {
      {?term rdf:type owl:Class}
      union
      {?term rdf:type rdfs:Class}.
      OPTIONAL {?term rdfs:label ?label}.
      OPTIONAL {?term rdfs:subClassOf ?superclass}.
      OPTIONAL {?term rdfs:comment ?comment}.
      }
      limit 1000
    "
  );
  $queries[] = array(
    'type' => 'property',
    'query' => "
      prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
      prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
      prefix owl: <http://www.w3.org/2002/07/owl#>
      select *
      from <$vocabulary_uri>
      where {
      { ?term rdf:type owl:DatatypeProperty }
      union
      { ?term rdf:type owl:ObjectProperty }
      union
      { ?term rdf:type rdf:Property } .
      OPTIONAL { ?term rdfs:label ?label } .
      OPTIONAL { ?term rdfs:domain ?domain } .
      OPTIONAL { ?term rdfs:range ?range } .
      OPTIONAL { ?term rdfs:comment ?comment } .
      }
      limit 1000
    "
  );
  // We have to try both the URI with the hash/slash and without, because
  // vocabularies like owl make assertions about the vocabulary usign the
  // non-hash URI.
  $vocabulary_uri_nohash = rtrim($vocabulary_uri, '/#');
  $queries[] = array(
    'type' => 'vocabulary_meta',
    'query' =>"
      prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
      prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
      prefix owl: <http://www.w3.org/2002/07/owl#>
      prefix vann: <http://purl.org/vocab/vann/>
      select *
      from <$vocabulary_uri>
      where {
      { ?uri rdf:type owl:Ontology}
      union
      { <$vocabulary_uri> ?p ?o  }
      union
      { <$vocabulary_uri_nohash> ?p ?o  }
      }
    "
  );
    $queries[] = array(
    'type' => 'dbpedia',
    'query' =>"
      prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
      prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
      prefix owl: <http://www.w3.org/2002/07/owl#>
      prefix vann: <http://purl.org/vocab/vann/>
      prefix dbp: <http://dbpedia.org/property/>
      select *
      from <http://dbpedia.org/sparql>
      where {
      { <http://dbpedia.org/resource/Semantic_Web> dbp:abstract ?val}
      }
      limit 100
    "
  );

  // Loop through all the various queries in order to extract as many classes
  // and properties as possible.
  foreach ($queries as $query) {
    $datasets = array($vocabulary_location);
    $sparql_results[$query['type']] = rdfx_sparql_request($query['query'], $datasets);
    if (!is_array($sparql_results)) {
      drupal_set_message("The SPARQL endpoint <a href=\"$endpoint\">$endpoint</a> returned an error. Please check it and make sure it allows to load from URIs via FROM clauses.", $type = 'warning', $repeat = FALSE);
    }
  }
  
  // We take out the vocabulary meta before processing the terms.
  $vocabulary_meta = $sparql_results['vocabulary_meta'];
  unset($sparql_results['vocabulary_meta']);*/
  
  module_load_include('inc', 'evoc', 'evoc.load_vocab');
  $test = evoc_get_from_web($vocabulary_uri, $vocabulary_prefix);
  dpm($test);
  
  // Process the terms from the ARC2 results into a usable array.
  foreach ($sparql_results as $term_type => $terms) {
    foreach($terms as $term) {
      // @todo Handle terms with multiple domains. ARC2 returns a blank node.
      
      // Check to see if there are language codes set for comments and labels.
      if (isset($term['label lang'])) {
        // Remove the region code if it is used (i.e. en-US is changed to en).
        $lang_array = explode('-', $term['label lang']);
        $langcode = !empty($lang_array[0]) ? $lang_array[0] : $term['label lang'];
      }
      else {
        // @todo Is the assumption appropriate that if no language is set,
        // English is the default language?
        $langcode = 'en';
      }
      $vocabulary[$term_type][$term['term']]['label'][$langcode] = $term['label'];
      
      // We create an associative array based on the language code of the
      // property. The language codes are specified in iso.inc.
      if (isset($term['comment lang'])) {
        // Chinese and Portuguese are the only languages with a >2 letter
        // langcode.
        if (preg_match('/(zh-hans)|(zh-hant)|(pt-pt)|(pt-br)/', $term['comment lang'])) {
          $langcode = $term['comment lang'];
        }
        // Remove the region code if it is used (i.e. en-US is changed to en).
        else {
          $lang_array = explode('-', $term['comment lang']);
          $langcode = !empty($lang_array[0]) ? $lang_array[0] : $term['comment lang'];
        }
      }
      else {
        // @todo Is the assumption appropriate that if no language is set,
        // English is the default language?
        $langcode = 'en';
      }
      $vocabulary[$term_type][$term['term']]['comment'][$langcode] = $term['comment'];
      
      // If this is a property, attach its domain and range.
      if (isset($term['domain'])) {
        if ($term['domain type'] == 'uri') {
          $vocabulary[$term_type][$term['term']]['domain'][] = $term['domain'];
        }
      }
      
      if (isset($term['range'])) {
        if ($term['range type'] == 'uri') {
          $vocabulary[$term_type][$term['term']]['range'][] = $term['range'];
        }
      }
    }
  }
    
    /*
     @todo move this to save vocab.
    // Get a list of the namespaces used in this vocabulary.
    $split_term = rdfx_uri_extract_parts($res_term[$type]);
    // @todo Is there anyway to figure out the namespace mapping defined in
    // the source file?
    if ($split_term['ns_uri'] != $vocabulary_uri) {
      $namespaces[] = $split_term['ns_uri'];
      }*/
  //dpm($sparql_results);
  //dpm($vocabulary);
  return $sparql_res;
}


function _evoc_save_rdf_terms($vocabulary_uri, $vocabulary_prefix, $terms) {
  $status = db_merge('evoc_rdf_properties')
    ->key(array(
      'nsid' => 2,
      'term' => 'term',
      'label' => 'test',
      'comment' => 'test',
      'rdf_domain' => 'test',
      'rdf_range' => 'test',
    ))
    ->execute();

  return $status;
}
