<?php
// $Id:  $

/**
 * @file
 * Allows to import external Vocabularies in order to map them to Drupal data
 * structure.
 */

/**
 * Implements hook_menu().
 */
function evoc_menu() {
  $items['evoc/import'] = array(
    'title' => 'Import external RDF vocabulary',
    'description' => 'Import RDF terms of an external vocabulary.',
    'page callback' => 'evoc_import',
    'access arguments' => array('administer content types'),
    'file' => 'evoc.pages.inc',
  );

  return $items;
}

/*
 * Import function for the evoc module.
 */
function evoc_import_vocabulary($vocabulary_uri, $vocabulary_prefix) {
  // Save the namespace to the namespace database table.
  // Prevent overriding an already defined prefix.
  // @todo this is only a temporary work around, see rdfx_namespace_save()
  $namespaces = rdfx_get_namespaces();
  if (empty($namespaces[$vocabulary_prefix])) {
    rdfx_namespace_save($vocabulary_uri, $vocabulary_prefix);
  }
  // Refresh the static variable that holds the array of namespaces.
  drupal_static_reset('rdfx_get_namespaces');
  $fetched_terms = evoc_fetch_vocabulary($vocabulary_uri, $vocabulary_prefix);

  _evoc_save_rdf_terms($vocabulary_uri, $vocabulary_prefix, $fetched_terms);
}

/**
 * Fetches the classes and properties of an external RDF vocabulary.
 *
 * @param $vocabulary_uri
 *   The namespace of the vocabulary to be fetched. Note most of the time this
 *   URI should end with / or #, e.g. http://rdfs.org/sioc/ns#
 * @param $vocabulary_prefix
 *   Prefix used system-wide for referring to this namespace.
 * @param $vocabulary_location
 *   URL of the vocabulary if the vocabulary namespace does not dereference and
 *   is not available at the namespace. Optionnal.
 * @param $ignore_base_ns
 *   Set to TRUE if all the terms found in the vocabulary should be imported
 *   regardless of whether they belong to the namespace or not. Optionnal.
 * @return
 *   An array of fetched terms.
 */
function evoc_fetch_vocabulary($vocabulary_uri, $vocabulary_prefix, $vocabulary_location = NULL, $ignore_base_ns = FALSE) {
  // TODO make sure the URI is valid either finishing with / or #
  // TODO make sure the prefix and the terms are not containing any forbidden characters.

  // Uses the vocabulary namespace URI if no specific location is given.
  $vocabulary_location = $vocabulary_location ? $vocabulary_location : $vocabulary_uri;

  // SPARQL queries are stored in an array.
  $term_queries = array();
  // Typical SPARQL queries to retrieve properties/classes, working for all major vocabularies...
//   $term_queries[] = array('type' => 'class',
//                      'query' => "
//   prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
//   prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
//   prefix owl: <http://www.w3.org/2002/07/owl#>
//   select *
//   from <$vocabulary_uri>
//   where {
//   {?class rdf:type owl:Class}
//   union
//   {?class rdf:type rdfs:Class}.
//   OPTIONAL {?class rdfs:label ?label}.
//   OPTIONAL {?class rdfs:subClassOf ?superclass}.
//   OPTIONAL {?class rdfs:comment ?comment}.
//   }
//   limit 1000
//   ");
  $term_queries[] = array('type' => 'property',
                     'query' => "
  prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
  prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
  prefix owl: <http://www.w3.org/2002/07/owl#>
  select *
  from <$vocabulary_uri>
  where {
  { ?property rdf:type owl:DatatypeProperty }
  union
  { ?property rdf:type owl:ObjectProperty }
  union
  { ?property rdf:type rdf:Property } .
  OPTIONAL { ?property rdfs:label ?label } .
  OPTIONAL { ?property rdfs:domain ?domain } .
  OPTIONAL { ?property rdfs:range ?range } .
  OPTIONAL { ?property rdfs:comment ?comment } .
  }
  limit 1000
  ");


  // Loop through all the various queries in order to extract as many classes
  // and properties as possible.
  $fetched_terms = array();
  foreach ($term_queries as $query) {
    $datasets = array($vocabulary_location);
    $sparql_res = rdfx_sparql_request($query['query'], $datasets);
    if (!is_array($sparql_res)) {
      drupal_set_message("The SPARQL endpoint <a href=\"$endpoint\">$endpoint</a> returned an error. Please check it and make sure it allows to load from URIs via FROM clauses.", $type = 'warning', $repeat = FALSE);
    }
    // Parse the SPARQL results and extract the relevant terms.
    foreach ($sparql_res as $res_term) {
      if (isset($res_term['class'])) {
        $type = 'class';
      }
      elseif (isset($res_term['property'])) {
        $type = 'property';
      }
      // Get the prefix associated with this term's URI.
      $term_qname = rdfx_uri_to_qname2($res_term[$type]);
      $term_qname_parts = explode(':', $term_qname);
      $term_prefix = $term_qname_parts[0];
      // We only import the terms with the specified prefix unless $ignore_base_ns is TRUE.
      if ($term_prefix == $vocabulary_prefix || $ignore_base_ns) {
        $term = array();
        $term['id'] = $term_qname_parts[1];
        $term['type'] = $type;
        $term['label'] = !empty($res_term['label']) ? $res_term['label'] : NULL;
        $term['comment'] = !empty($res_term['comment']) ? $res_term['comment'] : NULL;
        switch ($type) {
          case 'class' :
            $term['superclass'] = !empty($res_term['superclass']) ? rdf_uri_to_qname($res_term['superclass']) : NULL;
            break;

          case 'property' :
            // Extract some information like domain and range.
            $term['rdf_domain'] = !empty($res_term['domain']) ? rdfx_uri_to_qname2($res_term['domain']) : NULL;
            $term['rdf_range'] = !empty($res_term['range']) ? rdfx_uri_to_qname2($res_term['range']) : NULL;
            break;
        }
            // @TODO Clean up the terms to import and remove any duplicate? SPARQL should have done that already.
        $fetched_terms[] = $term;
      }
    }
  }
  return $fetched_terms;
}


function _evoc_save_rdf_terms($vocabulary_uri, $vocabulary_prefix, $terms) {
  return;
}
