<?php
// $Id:  $

/**
 * @file
 * Extends the RDF API of Drupal core to support more RDF seralizations formats
 * other RDF capabilities.
 */

/**
 * Namespace for the site vocabulary, used to generate local RDF properties and
 * classes for fields and content types.
 */
define('SITE_VOCABULARY_URI', url('ns', array('absolute' => TRUE, 'fragment' => ' ')));

/**
 * Path to the ARC2 PHP library.
 */
if (module_exists('libraries')) {
  define('RDF_ARC2_PATH', libraries_get_path('arc'));
}
else {
  define('RDF_ARC2_PATH', drupal_get_path('module', 'rdfx') . '/vendor/arc');
}

/**
 * Implements hook_init().
 */
function rdfx_init() {
  // Attempts to load the ARC2 library, if available.
  if (!class_exists('ARC2')) {
    @include_once RDF_ARC2_PATH . '/ARC2.php';
  }
}

/**
 * Implements hook_menu().
 */
function rdfx_menu() {
  $items['ns'] = array(
    'title' => 'Site vocabulary',
    'description' => 'RDF description of the site schema.',
    'page callback' => 'drupal_get_form',
//    'page arguments' => array(''),
    'access arguments' => array('access RDF data'),
    'file' => 'rdfx.pages.inc',
  );
  $items['node/%node/rdf'] = array(
    'title' => 'RDF',
    'page callback' => 'rdfx_entity_view',
    'page arguments' => array('node', 1),
    'access arguments' => array('access RDF data'),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
//    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'rdfx.pages.inc',
  );
  return $items;
}

/**
 * Executes a SPARQL query on either a local SPARQL engine if available or
 * attempts to find a working public SPARQL endpoint on the web.
 *
 * @param $query
 *   The SPARQL query to execute.
 * @param $datasets
 *   An array of datasets to query (optional). Implementation specific, i.e.
 *   ARC2 seems to require them to be pre-LOADed while public endpoints load
 *   FROM graphs automatically.
 * @return
 *   The SPARQL results.
 */
function rdfx_sparql_request($query, $datasets = array()) {
  // @todo Check if the datasets are available before trying to query them.

  // Converts to array is string given.
  if (!is_array($datasets)) {
    $datasets = array($datasets);
  }

  // Attempts to execute the SPARQL query on a local ARC2 library.
  // MySQL is required.
  $db_spec = $GLOBALS['databases']['default']['default'];
  if ($db_spec['driver'] = 'mysql' && class_exists('ARC2')) {
    // Sets up a local repository which is required for running SPARQL queries
    // with ARC2.
    // @todo randomize table name to support concurrent querying.
    $store = rdfx_arc2_init_store('rdfx_sparql_tmp');

    // Load each dataset in the store.
    foreach ($datasets as $url) {
      // @todo LOAD INTO <...>
      $q = "LOAD <$url>";
      $store->query($q);
    }
    $rs = $store->query($query);
    if (!$store->getErrors()) {
      $rows = $rs['result']['rows'];
    }
  }
  // Try to execute the query against a series of public SPARQL endpoints.
  else {
    $endpoints = array(
      'http://www.sparql.org/sparql',
      'http://demo.openlinksw.com/sparql/',
    );

    foreach ($endpoints as $endpoint) {
      // Initialize connection with the endpoint.
      $store = rdfx_arc2_init_remote_store($endpoint);

      // Execute the query.
      $rs = $store->query($query);
      if (!$store->getErrors()) {
        // Success!
        $rows = $rs['result']['rows'];
        // We have results so no point trying the other endpoints.
        break;
      }
    }
  }

  // Returns the errors if there are still no results at this stage.
  // @todo beware the query might have no result.
  if (empty($rows)) {
    return $store->getErrors();
  }

  return $rows;
}

/**
 * Gets a list of all defined namespaces.
 */
function rdfx_get_namespaces() {
  $rdf_namespaces = &drupal_static(__FUNCTION__);
  if (empty($rdf_namespaces)) {
    $rdf_namespaces = module_invoke_all('rdf_namespaces');
  }
  // @todo ensure there are no duplicates and that array is only one level.
  return $rdf_namespaces;
}

/**
 * Sets up an ARC2 RDF local repository.
 *
 * @param $name
 *   The name of the local repository.
 * @param $endpoint
 *   Set to TRUE if this store should also be setup as a SPARQL endpoint.
 * @return
 *   An ARC2 store object.
 */
function rdfx_arc2_init_store($name, $endpoint = FALSE) {
  // @todo fix this. Error reporting is off because ARC2 throws strict warnings.
  error_reporting(0);
  
  $db_spec = $GLOBALS['databases']['default']['default'];

  $config = array(
    /* db */
    'db_name' => $db_spec['database'],
    'db_user' => $db_spec['username'],
    'db_pwd' => isset($db_spec['password']) ? $db_spec['password'] : '',
    /* store */
    'store_name' => $name,

    /* endpoint */
    'endpoint_features' => array(
      'select', 'construct', 'ask', 'describe',
      //'load', 'insert', 'delete',
      'dump' /* dump is a special command for streaming SPOG export */
    ),
    'endpoint_timeout' => 60, /* not implemented in ARC2 preview */
    'endpoint_read_key' => '', /* optional */
    'endpoint_write_key' => '', /* optional */
    'endpoint_max_limit' => 500, /* optional */
  );

  // If this site is exposing a SPARQL endpoint, instantiate the endpoint with
  // the endpoint class which can be used for HTTP-based data access.
  if ($endpoint) {
    $store = ARC2::getStoreEndpoint($config);
  }
  // Otherwise, instantiate a locally accessible store.
  else {
    $store = ARC2::getStore($config);
  }
  if (!$store->isSetUp()) {
    $store->setUp();
  }

  return $store;
}

/**
 * Sets up an ARC2 RDF remote store.
 *
 * @param $endpoint
 *   The remote SPARQL endpoint.
 * @return
 *   An ARC2 store object.
 */
function rdfx_arc2_init_remote_store($endpoint) {
  /* configuration */
  $config = array(
    /* remote endpoint */
    'remote_store_endpoint' => $endpoint,
  );

  /* instantiation */
  $store = ARC2::getRemoteStore($config);

  return $store;
}

/**
 * Implements hook_rdf_namespaces.
 */
function rdfx_rdf_namespaces() {
  //$rdf_namespaces = db_query('SELECT prefix, uri FROM {rdfx_namespaces}')->fetchAllKeyed();
  //return $rdf_namespaces;
}

/**
 * Saves the main namespace mapping for a vocabulary graph and the additional
 * namespace mappings as defined in the document.
 */
function _rdfx_save_vocabulary($main_ns, $main_ns_prefix, $namespaces) {
  $current_time = REQUEST_TIME;
  // If the vocabulary URI matches the main_ns of a vocabulary source, then
  // this is an update to that record. Otherwise, this is a newly imported
  // source.
  $gids = db_select('rdfx_namespaces', 'rdfns', array());
  $gids->join('rdfx_vocabulary_graph', 'rdfvg', 'rdfvg.main_ns = rdfns.nsid');
  $gids
    ->fields('rdfns', array('gid'))
    ->condition('rdfns.uri', $main_ns);
  // @todo There should only be one result if there is a matching vocab source.
  // However, perhaps we should test to make sure and throw an error?
  $gid = $gids->execute()->fetchField();
  
  // If there is an existing vocabulary, make sure that the main_ns is in the
  // namespaces array and that the user defined mapping is the last in the
  // array so the prefix reflects the user definition. Also change the
  // vocabulary graph updated date.
  if ($gid) {
    $namespaces[$main_ns_prefix] = $main_ns;
    db_update('rdfx_vocabulary_graph')
      ->fields(array('date_updated' => $current_time,))
      ->execute();
  }

  // If this is a new vocabulary, create a graph with a main namespace and
  // add the additional namespaces.
  else {
    // @todo If the vocab URI isn't used in any terms, don't add it to ns table.
    // This may happen where multiple files are defining a vocabulary.
    
    // @todo This should be handled as a transaction in case there is an error
    // in the middle. If there is an error, then there will be an SQL error
    // when the user retries the import.
    
    // Insert this namespace to get the nsid. The vocabulary_source entry will
    // point to this nsid for the main_ns. We temporarily insert 0 for the gid,
    // then update when we have the real gid.
    $nsid = db_insert('rdfx_namespaces')
      ->fields(array('uri' => $main_ns, 'prefix' => $main_ns_prefix, 'gid' => '0'))
      ->execute();
    $gid = db_insert('rdfx_vocabulary_graph')
      ->fields(array(
          'main_ns' => $nsid,
          'date_created' => $current_time,
          'date_updated' => $current_time,))
      ->execute();
    db_update('rdfx_namespaces')
      ->condition('nsid', $nsid)
      ->fields(array('gid' => $gid))
      ->execute();
  }
  // Insert/update the other namespace mappings used in this vocabulary graph.
  if (count($namespaces) > 0) {      
    foreach ($namespaces as $prefix => $namespace) {
      $query = db_merge('rdfx_namespaces')
        ->key(array('gid' => $gid, 'uri' => $namespace))
        ->fields(array('uri' => $namespace, 'prefix' => $prefix, 'gid' => $gid))
        ->update(array('prefix' => $prefix));
      $test = $query->execute();
    }
  }

  $nsids = db_query("SELECT uri, nsid FROM {rdfx_namespaces} WHERE gid = :gid",
    array(':gid' => $gid,))
    ->fetchAllKeyed();
  return $nsids;
}

/**
 * Saves vocabulary terms.
 */
function rdfx_save_terms($vocabulary_uri, $prefix, $vocabulary) {
  $nsids = _rdfx_save_vocabulary($vocabulary_uri, $prefix, $vocabulary['namespaces']);
  
}

/**
 * Splits a URI into namespace and localpart.
 */
function rdfx_split_uri ($uri) {
  $parts = ARC2::splitURI($uri);
}