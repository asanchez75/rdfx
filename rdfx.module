<?php
// $Id:  $

/**
 * @file
 * Extends the RDF API of Drupal core to support more RDF seralizations formats
 * other RDF capabilities.
 */

/**
 * Namespace for the site vocabulary, used to generate local RDF properties and
 * classes for fields and content types.
 */
define('SITE_VOCABULARY_URI', url('ns', array('absolute' => TRUE, 'fragment' => ' ')));

/**
 * Constants for the 

/**
 * Path to the ARC2 PHP library.
 */
if (module_exists('libraries')) {
  define('RDF_ARC2_PATH', libraries_get_path('arc'));
}
else {
  define('RDF_ARC2_PATH', drupal_get_path('module', 'rdfx') . '/vendor/arc');
}

/**
 * Implements hook_init().
 */
function rdfx_init() {
  // Attempts to load the ARC2 library, if available.
  if (!class_exists('ARC2')) {
    @include_once RDF_ARC2_PATH . '/ARC2.php';
  }
}

/**
 * Implements hook_menu().
 */
function rdfx_menu() {
  $items['ns'] = array(
    'title' => 'Site vocabulary',
    'description' => 'RDF description of the site schema.',
    'page callback' => 'drupal_get_form',
//    'page arguments' => array(''),
    'access arguments' => array('access RDF data'),
    'file' => 'rdfx.pages.inc',
  );
  $items['node/%node/rdf'] = array(
    'title' => 'RDF',
    'page callback' => 'rdfx_entity_view',
    'page arguments' => array('node', 1),
    'access arguments' => array('access RDF data'),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
//    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'rdfx.pages.inc',
  );
  return $items;
}

/**
 * Gets a list of all defined namespaces.
 */
function rdfx_get_namespaces() {
  $rdf_namespaces = &drupal_static(__FUNCTION__);
  if (empty($rdf_namespaces)) {
    $rdf_namespaces = module_invoke_all('rdf_namespaces');
  }
  // @todo ensure there are no duplicates and that array is only one level.
  return $rdf_namespaces;
}

/**
 * Implements hook_rdf_namespaces.
 */
function rdfx_rdf_namespaces() {
  //$rdf_namespaces = db_query('SELECT prefix, uri FROM {rdfx_namespaces}')->fetchAllKeyed();
  //return $rdf_namespaces;
}

/**
 * Saves the main namespace mapping for a vocabulary graph and the additional
 * namespace mappings as defined in the document.
 */
function _rdfx_save_vocabulary($main_ns, $main_ns_prefix, $namespaces) {
  $current_time = REQUEST_TIME;
  // If the vocabulary URI matches the main_ns of a vocabulary source, then
  // this is an update to that record. Otherwise, this is a newly imported
  // source.
  $gids = db_select('rdfx_namespaces', 'rdfns', array());
  $gids->join('rdfx_vocabulary_graph', 'rdfvg', 'rdfvg.main_ns = rdfns.nsid');
  $gids
    ->fields('rdfns', array('gid'))
    ->condition('rdfns.uri', $main_ns);
  // @todo There should only be one result if there is a matching vocab source.
  // However, perhaps we should test to make sure and throw an error?
  $gid = $gids->execute()->fetchField();
  
  // If there is an existing vocabulary, make sure that the main_ns is in the
  // namespaces array and that the user defined mapping is the last in the
  // array so the prefix reflects the user definition. Also change the
  // vocabulary graph updated date.
  if ($gid) {
    $namespaces[$main_ns_prefix] = $main_ns;
    db_update('rdfx_vocabulary_graph')
      ->fields(array('date_updated' => $current_time,))
      ->execute();
  }

  // If this is a new vocabulary, create a graph with a main namespace and
  // add the additional namespaces.
  else {
    // @todo If the vocab URI isn't used in any terms, don't add it to ns table.
    // This may happen where multiple files are defining a vocabulary.
    
    // @todo This should be handled as a transaction in case there is an error
    // in the middle. If there is an error, then there will be an SQL error
    // when the user retries the import.
    
    // Insert this namespace to get the nsid. The vocabulary_source entry will
    // point to this nsid for the main_ns. We temporarily insert 0 for the gid,
    // then update when we have the real gid.
    $nsid = db_insert('rdfx_namespaces')
      ->fields(array('uri' => $main_ns, 'prefix' => $main_ns_prefix, 'gid' => '0'))
      ->execute();
    $gid = db_insert('rdfx_vocabulary_graph')
      ->fields(array(
          'main_ns' => $nsid,
          'date_created' => $current_time,
          'date_updated' => $current_time,))
      ->execute();
    db_update('rdfx_namespaces')
      ->condition('nsid', $nsid)
      ->fields(array('gid' => $gid))
      ->execute();
  }
  // Insert/update the other namespace mappings used in this vocabulary graph.
  if (count($namespaces) > 0) {      
    foreach ($namespaces as $prefix => $namespace) {
      $query = db_merge('rdfx_namespaces')
        ->key(array('gid' => $gid, 'uri' => $namespace))
        ->fields(array('uri' => $namespace, 'prefix' => $prefix, 'gid' => $gid))
        ->update(array('prefix' => $prefix));
      $test = $query->execute();
    }
  }

  $nsids = db_query("SELECT uri, nsid FROM {rdfx_namespaces} WHERE gid = :gid",
    array(':gid' => $gid,))
    ->fetchAllKeyed();
  return $nsids;
}

/**
 * Saves vocabulary terms.
 */
function rdfx_save_terms($vocabulary_uri, $prefix, $vocabulary) {
  dpm($vocabulary);
  $nsids = _rdfx_save_vocabulary($vocabulary_uri, $prefix, $vocabulary['namespaces']);
  // @todo Add a hook that passes the $vocabulary and the $model.
}

/**
 * Returns metadata about term types defined by rdf modules.
 *
 * If your module needs to determine what term types are being supplied by
 * other modules, call this function. Querying rdfx database tables directly
 * for this information is discouraged. Any additional term types should be
 * added through the corresponding alter hook.
 *
 * Three major bins of data are stored: tags, value_types, and functions. Each
 * entry in these bins is keyed by the value stored in the actual VotingAPI
 * tables, and contains an array with (minimally) 'name' and 'description' keys.
 * Modules can add extra keys to their entries if desired.
 *
 * This metadata can be modified or expanded using hook_rdfx_term_types_alter().
 *
 * @return
 *   An array of metadata defined by RDFx Terms and altered by rdf modules.
 *
 * @see hook_rdfx_term_types_alter()
 *
 * Modeled on VotingAPI votingapi_metadata.
 */
function rdfx_term_types($reset = FALSE) {
  static $types;
  if ($reset || !isset($types)) {
    $types['classes']['term_types'] = array();
    $types['properties']['term_types'] = array();
    
    $term_details = '';
    
    // @todo Should the inference consider subProp and subClass relationships
    // as well. ie. should all OWL classes also have the type RDFS Class
    
    // @todo Switch to drupal cache
    $types['classes']['term_types']['rdfs_class'] = array(
      'uri' => 'http://www.w3.org/2000/01/rdf-schema#Class',
      'inference' => array(
        'subject' => array(
          'http://www.w3.org/2000/01/rdf-schema#subClassOf',
        ),
        'object' => array(
          'http://www.w3.org/2000/01/rdf-schema#subClassOf',
          'http://www.w3.org/2000/01/rdf-schema#domain',
          'http://www.w3.org/2000/01/rdf-schema#range',
        ),
      ),
    );
    $types['classes']['term_types']['owl_class'] = array(
      'uri' => 'http://www.w3.org/2002/07/owl#Class',
      'inference' => array(
        'subject' => array(
          'http://www.w3.org/2002/07/owl#equivalentClass',
          'http://www.w3.org/2002/07/owl#disjointWith',
        ),
        'object' => array(
          'http://www.w3.org/2002/07/owl#equivalentClass',
          'http://www.w3.org/2002/07/owl#disjointWith',
        ),
      ),
    );

    $types['properties']['term_types']['rdf_property'] = array(
      'uri' => 'http://www.w3.org/1999/02/22-rdf-syntax-ns#Property',
      'inference' => array(
        'subject' => array(
        ),
        'object' => array(
        ),
      ),
    );
    $types['properties']['term_types']['owl_property_datatype'] = array(
      'uri' => 'http://www.w3.org/2002/07/owl#DatatypeProperty',
      'inference' => array(
        'subject' => array(
        ),
        'object' => array(
        ),
      ),
    );
    $types['properties']['term_types']['owl_property_object'] = array(
      'uri' => 'http://www.w3.org/2002/07/owl#ObjectProperty',
      'inference' => array(
        'subject' => array(
        ),
        'object' => array(
        ),
      ),
    );
    
    $types['classes']['description'] = array(
      /*'domain' => array(
        'subject' => array(
          'http://www.w3.org/2000/01/rdf-schema#domain',
        ),
        'object' => array(
        ),
      ),*/
    );
    
    $types['properties']['description'] = array(
      'domain' => array(
        'subject' => array(
          'http://www.w3.org/2000/01/rdf-schema#domain',
        ),
        'object' => array(
        ),
      ),
      'range' => array(
        'subject' => array(
          'http://www.w3.org/2000/01/rdf-schema#range',
        ),
        'object' => array(
        ),
      ),
    );
    drupal_alter('rdfx_term_types', $types);
  }

  return $types;
}

/**
 * Splits a URI into namespace and localpart.
 */
function rdfx_split_uri ($uri) {
  $parts = ARC2::splitURI($uri);
}

