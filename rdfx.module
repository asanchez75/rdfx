<?php
// $Id:  $

/**
 * @file
 * Extends the RDF API of Drupal core to support more RDF seralizations formats
 * other RDF capabilities.
 */

/**
 * Namespace for the site vocabulary, used to generate local RDF properties and
 * classes for fields and content types.
 */
define('SITE_VOCABULARY_URI', url('ns', array('absolute' => TRUE, 'fragment' => ' ')));

/**
 * Path to the ARC2 PHP library.
 */
if (module_exists('libraries')) {
  define('RDF_ARC2_PATH', libraries_get_path('arc'));
}
else {
  define('RDF_ARC2_PATH', drupal_get_path('module', 'rdfx') . '/vendor/arc');
}

/**
 * Implements hook_init().
 */
function rdfx_init() {
  // Attempts to load the ARC2 library, if available.
  if (!class_exists('ARC2')) {
    @include_once RDF_ARC2_PATH . '/ARC2.php';
  }
  module_load_include('inc', 'rdfx', 'rdfx.terms');
  module_load_include('inc', 'rdfx', 'rdfx.import');
  module_load_include('inc', 'rdfx', 'rdfx.query');
}

/**
 * Implements hook_menu().
 */
function rdfx_menu() {
  $items['ns'] = array(
    'title' => 'Site vocabulary',
    'description' => 'RDF description of the site schema.',
    'page callback' => 'drupal_get_form',
    'access arguments' => array('access RDF data'),
    'file' => 'rdfx.pages.inc',
  );
  $items['node/%node/rdf'] = array(
    'title' => 'RDF',
    'page callback' => 'rdfx_entity_view',
    'page arguments' => array('node', 1),
    'access arguments' => array('access RDF data'),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'file' => 'rdfx.pages.inc',
  );
  return $items;
}

/**
 * Constructs the RDF representation of an entity of type node.
 */
function rdfx_build_rdf_node($node) {
  // URI of the node.
  $doc_uri = url('node/' . $node->nid, array('absolute' => TRUE));
  // URI of the resource being described in the node.
  // @todo allow for customized resource uris.
  $res_uri = url('node/' . $node->nid . '#this');

  // Instanciate node resource as ARC2 class and set base and namespaces.
  $res = ARC2::getResource();
  $res->setUri($doc_uri);
  $res->base = url('', array('absolute' => TRUE));
  $res->ns = rdfx_get_namespaces();

  // Container for the triples about the document.
  $doc_props = array();

  // Only include data which has RDF mapping associated with it.
  foreach ($node->rdf_mapping as $name => $mapping) {
    switch ($name) {
      // Non field API properties.
      case 'rdftype' :
         $doc_props['rdf:type'] = $node->rdf_mapping['rdftype'];
      break;

      case 'title' :
        $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $node->$name);
      break;

      case 'created' :
        // @todo creation date: the user should be able to opt in/out.
        // @todo modified date: the user should be able to opt in/out.
        $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $node->$name);
      break;

      case 'created' :
        $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $node->$name);
      break;

      case 'uid' :
        // We need to pass the uri of the sioc:has_creator user.
        $user_uri = url('user/' . $node->uid, array('absolute' => TRUE));
        $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $user_uri);
      break;

      case 'comment_count' :
        $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $node->$name);
      break;
    }
  }

  // Attach the node properties to the document URI.
  $index[$doc_uri] = $doc_props;
  // Expand all CURIEs and attach the index to the ARC2 resource.
  $res->index = $res->expandPNames($index);

  return $res;
}

/**
 * Helper function to build an ARC2 index composed of predicates and objects.
 */
function _rdfx_build_arc2_index_p_o($mapping, $data = NULL) {
  // The type of mapping defaults to 'property'.
  $type = isset($mapping['type']) ? $mapping['type'] : 'property';

  switch ($type) {
    // The mapping expresses the relationship between two resources.
    case 'rel':
      foreach ($mapping['predicates'] as $p) {
        $props[$p][] = array(
          'value' => $data,
          'type' => 'uri',
        );
      }
      break;

    case 'rev': // Not supported yet.
      // @todo
      break;

    // The mapping expresses the relationship between a resource and some
    // literal text.
    case 'property':
      // Convert $data to a specific format as per the callback function.
      if (isset($data) && isset($mapping['callback']) && function_exists($mapping['callback'])) {
        $callback = $mapping['callback'];
        $data = $callback($data);
      }
      foreach ($mapping['predicates'] as $p) {
        $props[$p][] = array(
          'value' => $data,
          'type' => 'literal',
          'datatype' => isset($mapping['datatype']) ? $mapping['datatype'] : '',
        );
      }
      break;
  }

  return $props;
}
