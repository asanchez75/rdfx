<?php
// $Id:  $

/**
 * @file
 * Extends the RDF API of Drupal core to support more RDF seralizations formats
 * other RDF capabilities.
 */

/**
 * Namespace for the site vocabulary, used to generate local RDF properties and
 * classes for fields and content types.
 */
define('SITE_VOCABULARY_URI', url('ns', array('absolute' => TRUE, 'fragment' => ' ')));

/**
 * Path to the ARC2 PHP library.
 */
if (module_exists('libraries')) {
  define('RDF_ARC2_PATH', libraries_get_path('arc'));
}
else {
  define('RDF_ARC2_PATH', drupal_get_path('module', 'rdfx') . '/vendor/arc');
}

/**
 * Implements hook_init().
 */
function rdfx_init() {
  // Attempts to load the ARC2 library, if available.
  if (!class_exists('ARC2')) {
    @include_once RDF_ARC2_PATH . '/ARC2.php';
  }
  module_load_include('inc', 'rdfx', 'rdfx.terms');
  module_load_include('inc', 'rdfx', 'rdfx.import');
  module_load_include('inc', 'rdfx', 'rdfx.query');
}

/**
 * Implements hook_menu().
 */
function rdfx_menu() {
  $items['ns'] = array(
    'title' => 'Site vocabulary',
    'description' => 'RDF description of the site schema.',
    'page callback' => 'drupal_get_form',
    'access arguments' => array('access RDF data'),
    'file' => 'rdfx.pages.inc',
  );
  $items['node/%node/rdf'] = array(
    'title' => 'RDF',
    'page callback' => 'rdfx_entity_view',
    'page arguments' => array('node', 1),
    'access arguments' => array('access RDF data'),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'file' => 'rdfx.pages.inc',
  );
  return $items;
}

/**
 * Constructs the RDF representation of an entity of type node.
 */
function rdfx_build_rdf_node($node) {
  // URI of the node.
  $doc_uri = url('node/' . $node->nid, array('absolute' => TRUE));
  // URI of the resource being described in the node.
  // @todo allow for customized resource uris.
  $res_uri = url('node/' . $node->nid . '#this');

  // Instanciate node resource as ARC2 class and set base and namespaces.
  $res = ARC2::getResource();
  $res->setUri($doc_uri);
  $res->base = url('', array('absolute' => TRUE));
  $res->ns = rdfx_get_namespaces();

  // Container for the triples about the document.
  $doc_props = array();

  // Only include data which has RDF mapping associated with it.
  foreach ($node->rdf_mapping as $name => $mapping) {
    switch ($name) {
      // Non field API properties.
      case 'rdftype' :
        $doc_props['rdf:type'] = $node->rdf_mapping['rdftype'];
        break;

      case 'title' :
        $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $node->$name);
        break;

      case 'created' :
        // @todo creation date: the user should be able to opt in/out.
        // @todo modified date: the user should be able to opt in/out.
        $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $node->$name);
        break;

      case 'created' :
        $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $node->$name);
        break;

      case 'uid' :
        // We need to pass the uri of the sioc:has_creator user.
        $user_uri = url('user/' . $node->uid, array('absolute' => TRUE));
        $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $user_uri);
        break;

      case 'comment_count' :
        $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $node->$name);
        break;

      // Additionally, include RDF data from Field API fields.
      default :
        if (isset($node->$name) && $field_info = field_info_field($name)) {
          // Items which will be exported as objects.
          $items = array();
          switch ($field_info['type']) {
            case 'image' :
              // @todo type object with foaf:Image.
              // @todo export all images with some metadata (size) about them?
            case 'file' :
              // @todo support translatable.
              if (isset($node->{$name}['und'])) {
                foreach ($node->{$name}['und'] as $item) {
                  $items[] = file_create_url($item['uri']);
                }
                $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $items);
              }
              break;

            case 'taxonomy_term_reference' :
              // @todo support translatable.
              if (isset($node->{$name}['und'])) {
                foreach ($node->{$name}['und'] as $item) {
                  $items[] = url('taxonomy/term/' . $item['tid'], array('absolute' => TRUE));
                }
                $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $items);
              }
              break;

            case 'node_reference' :
              // @todo support translatable.
              if (isset($node->{$name}['und'])) {
                foreach ($node->{$name}['und'] as $item) {
                  $items[] = url('node/' . $item['nid'], array('absolute' => TRUE));
                }
                $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $items);
              }
              break;

            case 'user_reference' :
              // @todo support translatable.
              if (isset($node->{$name}['und'])) {
                foreach ($node->{$name}['und'] as $item) {
                  $items[] = url('user/' . $item['uid'], array('absolute' => TRUE));
                }
                $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $items);
              }
              break;

            case 'text_with_summary' :
            case 'text_long' :
              // Forces datatype to rdf:XMLLiteral since it's most likely HTML.
              // @todo check the input format to check whether it's HTML or not.
              if (empty($node->rdf_mapping[$name]['datatype'])) {
                $node->rdf_mapping[$name]['datatype'] = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral';
              }
            case 'text' :
              // @todo support translatable.
              foreach ($node->{$name}['und'] as $item) {
                $items[] = $item['safe_value'];
              }
              $doc_props += _rdfx_build_arc2_index_p_o($node->rdf_mapping[$name], $items);
              break;
          }
        }
    }
  }

  // Attach the node properties to the document URI.
  $index[$doc_uri] = $doc_props;
  // Expand all CURIEs and attach the index to the ARC2 resource.
  $res->index = $res->expandPNames($index);

  return $res;
}

/**
 * Helper function to build an ARC2 index composed of predicates and objects.
 */
function _rdfx_build_arc2_index_p_o($mapping, $data = NULL) {
  // The type of mapping defaults to 'property'.
  $type = isset($mapping['type']) ? $mapping['type'] : 'property';

  switch ($type) {
    // The mapping expresses the relationship between two resources.
    case 'rel':
      foreach ($mapping['predicates'] as $p) {
        if (!is_array($data)) {
          $data = array($data);
        }
        foreach ($data as $data_item) {
          $props[$p][] = array(
            'value' => $data_item,
            'type' => 'uri',
          );
        }
      }
      break;

    case 'rev': // Not supported yet.
      // @todo
      break;

    // The mapping expresses the relationship between a resource and some
    // literal text.
    case 'property':
      // Convert $data to a specific format as per the callback function.
      if (isset($data) && isset($mapping['callback']) && function_exists($mapping['callback'])) {
        $callback = $mapping['callback'];
        $data = $callback($data);
      }
      foreach ($mapping['predicates'] as $p) {
        if (!is_array($data)) {
          $data = array($data);
        }
        foreach ($data as $data_item) {
          $props[$p][] = array(
            'value' => $data_item,
            'type' => 'literal',
            'datatype' => isset($mapping['datatype']) ? $mapping['datatype'] : '',
          );
        }
      }
      break;
  }

  return $props;
}
