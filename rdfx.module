<?php
// $Id:  $

/**
 * @file
 * Extends the RDF API of Drupal core to support more RDF seralizations formats
 * other RDF capabilities.
 */

/**
 * Namespace for the site vocabulary, used to generate local RDF properties and
 * classes for fields and content types.
 */
define('SITE_VOCABULARY_URI', url('ns', array('absolute' => TRUE, 'fragment' => ' ')));

/**
 * Path to the ARC2 PHP library.
 */
if (module_exists('libraries')) {
  define('RDF_ARC2_PATH', libraries_get_path('arc'));
}
else {
  define('RDF_ARC2_PATH', drupal_get_path('module', 'rdfx') . '/vendor/arc');
}

/**
 * Implements hook_init().
 */
function rdfx_init() {
  // Attempts to load the ARC2 library, if available.
  if (!class_exists('ARC2')) {
    @include_once RDF_ARC2_PATH . '/ARC2.php';
  }
}

/**
 * Implements hook_menu().
 */
function rdfx_menu() {
  $items['ns'] = array(
    'title' => 'Site vocabulary',
    'description' => 'RDF description of the site schema.',
    'page callback' => 'drupal_get_form',
//    'page arguments' => array(''),
    'access arguments' => array('access RDF data'),
    'file' => 'rdfx.pages.inc',
  );
  $items['node/%node/rdf'] = array(
    'title' => 'RDF',
    'page callback' => 'rdfx_entity_view',
    'page arguments' => array('node', 1),
    'access arguments' => array('access RDF data'),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
//    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'rdfx.pages.inc',
  );
  return $items;
}

/**
 * Executes a SPARQL query on either a local SPARQL engine if available or
 * attempts to find a working public SPARQL endpoint on the web.
 *
 * @param $query
 *   The SPARQL query to execute.
 * @param $datasets
 *   An array of datasets to query (optional). Implementation specific, i.e.
 *   ARC2 seems to require them to be pre-LOADed while public endpoints load
 *   FROM graphs automatically.
 * @return
 *   The SPARQL results.
 */
function rdfx_sparql_request($query, $datasets = array()) {
  // @todo Check if the datasets are available before trying to query them.

  // Converts to array is string given.
  if (!is_array($datasets)) {
    $datasets = array($datasets);
  }

  // Attempts to execute the SPARQL query on a local ARC2 library.
  // MySQL is required.
  $db_spec = $GLOBALS['databases']['default']['default'];
  if ($db_spec['driver'] = 'mysql' && class_exists('ARC2')) {
    // Sets up a local repository which is required for running SPARQL queries
    // with ARC2.
    // @todo randomize table name to support concurrent querying.
    $store = rdfx_arc2_init_store('rdfx_sparql_tmp');

    // Load each dataset in the store.
    foreach ($datasets as $url) {
      // @todo LOAD INTO <...>
      $q = "LOAD <$url>";
      $store->query($q);
    }
    $rs = $store->query($query);
    if (!$store->getErrors()) {
      $rows = $rs['result']['rows'];
    }
  }
  // Try to execute the query against a series of public SPARQL endpoints.
  else {
    $endpoints = array(
      'http://www.sparql.org/sparql',
      'http://demo.openlinksw.com/sparql/',
    );

    foreach ($endpoints as $endpoint) {
      // Initialize connection with the endpoint.
      $store = rdfx_arc2_init_remote_store($endpoint);

      // Execute the query.
      $rs = $store->query($query);
      if (!$store->getErrors()) {
        // Success!
        $rows = $rs['result']['rows'];
        // We have results so no point trying the other endpoints.
        break;
      }
    }
  }

  // Returns the errors if there are still no results at this stage.
  // @todo beware the query might have no result.
  if (empty($rows)) {
    return $store->getErrors();
  }

  return $rows;
}

function rdfx_uri_to_qname ($uri) {
  // If this isn't a valid URI, we cannot parse it.
  if (!valid_url($uri)) {
    return $uri;
  }

  $uri_parts = rdfx_uri_extract_parts($uri);
  if (!empty($uri_parts['local_part'])) {
    $prefix = rdfx_get_prefix($uri_parts['ns_uri']);
    return $prefix . ':' . $uri_parts['local_part'];
  }
  else {
    drupal_set_message('Error processing ' . $uri);
  }
}

/**
 * Finds the prefix assigned to a namespace URI.
 */
function rdfx_get_prefix($uri) {
  $rdf_namespaces = rdfx_get_namespaces();
  while ($namespace = current($rdf_namespaces)) {
    if ($namespace == $uri) {
      return key($rdf_namespaces);
    }
    next($rdf_namespaces);
  }
}

/**
 * Gets a list of all defined namespaces.
 */
function rdfx_get_namespaces() {
  $rdf_namespaces = &drupal_static(__FUNCTION__);
  if (empty($rdf_namespaces)) {
    $rdf_namespaces = module_invoke_all('rdf_namespaces');
  }
  // @todo ensure there are no duplicates and that array is only one level.
  return $rdf_namespaces;
}

/**
 * Extracts the vocabulary namespace URI and local part from a URI.
 *
 * @param $uri
 *   URI to split.
 * @return $uri_parts
 *   An array containing the namespace uri ('ns_uri') and the 'local_part'.
 */
function rdfx_uri_extract_parts($uri) {
  // Local parts cannot contain '/' (slash) or '#' (hash). Therefore, we can
  // split the URI at the last delimiter into the namespace URI and the local
  // part.

  $uri_parts = array();
  // Since we have already tested to ensure this is a valid URL, we don't check
  // for illegal characters. We use look ahead negation to make sure the hash
  // is the last delimiting character.
  $uri_split = preg_split('/(\S*#(?!.*#)(?!.*\/))/', $uri, NULL, PREG_SPLIT_DELIM_CAPTURE);
  if (!empty($uri_split[1])) {
    $uri_parts['ns_uri'] = $uri_split[1];
    $uri_parts['local_part'] = $uri_split[2];
  }
  // If there is a slash after the last hash, it is a slash URI so we simply
  // look for the last slash.
  else {
    $uri_split = preg_split('/(\S*\/(?!.*\/))/', $uri, NULL, PREG_SPLIT_DELIM_CAPTURE);
    $uri_parts['ns_uri'] = $uri_split[1];
    $uri_parts['local_part'] = $uri_split[2];
  }

  return $uri_parts;
}


/**
 * Sets up an ARC2 RDF local repository.
 *
 * @param $name
 *   The name of the local repository.
 * @param $endpoint
 *   Set to TRUE if this store should also be setup as a SPARQL endpoint.
 * @return
 *   An ARC2 store object.
 */
function rdfx_arc2_init_store($name, $endpoint = FALSE) {
  // @todo fix this. Error reporting is off because ARC2 throws strict warnings.
  error_reporting(0);
  
  $db_spec = $GLOBALS['databases']['default']['default'];

  $config = array(
    /* db */
    'db_name' => $db_spec['database'],
    'db_user' => $db_spec['username'],
    'db_pwd' => isset($db_spec['password']) ? $db_spec['password'] : '',
    /* store */
    'store_name' => $name,

    /* endpoint */
    'endpoint_features' => array(
      'select', 'construct', 'ask', 'describe',
      //'load', 'insert', 'delete',
      'dump' /* dump is a special command for streaming SPOG export */
    ),
    'endpoint_timeout' => 60, /* not implemented in ARC2 preview */
    'endpoint_read_key' => '', /* optional */
    'endpoint_write_key' => '', /* optional */
    'endpoint_max_limit' => 500, /* optional */
  );

  // If this site is exposing a SPARQL endpoint, instantiate the endpoint with
  // the endpoint class which can be used for HTTP-based data access.
  if ($endpoint) {
    $store = ARC2::getStoreEndpoint($config);
  }
  // Otherwise, instantiate a locally accessible store.
  else {
    $store = ARC2::getStore($config);
  }
  if (!$store->isSetUp()) {
    $store->setUp();
  }

  return $store;
}

/**
 * Sets up an ARC2 RDF remote store.
 *
 * @param $endpoint
 *   The remote SPARQL endpoint.
 * @return
 *   An ARC2 store object.
 */
function rdfx_arc2_init_remote_store($endpoint) {
  /* configuration */
  $config = array(
    /* remote endpoint */
    'remote_store_endpoint' => $endpoint,
  );

  /* instantiation */
  $store = ARC2::getRemoteStore($config);

  return $store;
}

/**
 * Implements hook_rdf_namespaces.
 */
function rdfx_rdf_namespaces() {
  //$rdf_namespaces = db_query('SELECT prefix, uri FROM {rdfx_namespaces}')->fetchAllKeyed();
  //return $rdf_namespaces;
}


/**
 * Saves an RDF prefix/namespace pair to the database.
 *
 * @param $vocabulary_uri
 * @param $vocabulary_prefix
 *
 * @return
 *   Status flag indicating the outcome of the operation.
 */
/*function rdfx_namespace_save($vocabulary_uri, $vocabulary_prefix) {
  // @todo If a namespace is defined in a module, how will we avoid collision
  // with namespaces defined by the user? For instance, if the user defines
  // the 'media' ns as http://digitalbazaar.com/media but a module defines it as
  // the Yahoo vocabulary. See Issue 8 on GitHub.

  $status = db_merge('rdfx_namespaces')
    ->key(array(
      'prefix' => $vocabulary_prefix,
      'uri' => $vocabulary_uri,
    ))
    ->execute();

  return $status;
}*/

/**
 * Saves the main namespace mapping for a vocabulary graph and the additional
 * namespace mappings as defined in the document.
 */
function _rdfx_save_vocabulary($main_ns, $main_ns_prefix, $namespaces) {
  $current_time = REQUEST_TIME;
  // If the vocabulary URI matches the main_ns of a vocabulary source, then
  // this is an update to that record. Otherwise, this is a newly imported
  // source.
  $gids = db_select('rdfx_namespaces', 'rdfns', array());
  $gids->join('rdfx_vocabulary_graph', 'rdfvg', 'rdfvg.main_ns = rdfns.nsid');
  $gids
    ->fields('rdfns', array('gid'))
    ->condition('rdfns.uri', $main_ns);
  // @todo There should only be one result if there is a matching vocab source.
  // However, perhaps we should test to make sure and throw an error?
  $gid = $gids->execute()->fetchField();
  
  // If there is an existing vocabulary, make sure that the main_ns is in the
  // namespaces array and that the user defined mapping is the last in the
  // array so the prefix reflects the user definition. Also change the
  // vocabulary graph updated date.
  if ($gid) {
    $namespaces[$main_ns_prefix] = $main_ns;
    db_update('rdfx_vocabulary_graph')
      ->fields(array('date_updated' => $current_time,))
      ->execute();
  }

  // If this is a new vocabulary, create a graph with a main namespace and
  // add the additional namespaces.
  else {
    // @todo If the vocab URI isn't used in any terms, don't add it to ns table.
    // This may happen where multiple files are defining a vocabulary.
    
    // @todo This should be handled as a transaction in case there is an error
    // in the middle. If there is an error, then there will be an SQL error
    // when the user retries the import.
    
    // Insert this namespace to get the nsid. The vocabulary_source entry will
    // point to this nsid for the main_ns. We temporarily insert 0 for the gid,
    // then update when we have the real gid.
    $nsid = db_insert('rdfx_namespaces')
      ->fields(array('uri' => $main_ns, 'prefix' => $main_ns_prefix, 'gid' => '0'))
      ->execute();
    $gid = db_insert('rdfx_vocabulary_graph')
      ->fields(array(
          'main_ns' => $nsid,
          'date_created' => $current_time,
          'date_updated' => $current_time,))
      ->execute();
    db_update('rdfx_namespaces')
      ->condition('nsid', $nsid)
      ->fields(array('gid' => $gid))
      ->execute();
  }
  // Insert/update the other namespace mappings used in this vocabulary graph.
  if (count($namespaces) > 0) {      
    foreach ($namespaces as $prefix => $namespace) {
      $query = db_merge('rdfx_namespaces')
        ->key(array('gid' => $gid, 'uri' => $namespace))
        ->fields(array('uri' => $namespace, 'prefix' => $prefix, 'gid' => $gid))
        ->update(array('prefix' => $prefix));
      $test = $query->execute();
    }
  }

  $nsids = db_query("SELECT uri, nsid FROM {rdfx_namespaces} WHERE gid = :gid",
    array(':gid' => $gid,))
    ->fetchAllKeyed();
  return $nsids;
}


/**
 * Saves vocabulary terms.
 */
function rdfx_save_terms($vocabulary_uri, $prefix, $vocabulary) {
  $nsids = _rdfx_save_vocabulary($vocabulary_uri, $prefix, $vocabulary['namespaces']);
  dpm($vocabulary);
}

// @todo merge this with rdfx_uri_to_qname()
/*function rdfx_uri_to_qname2($uri, $gensym = TRUE, $fail = NULL) {
  $rdf_namespaces = rdfx_get_namespaces();
  $best_prefix = $best_match = '';

  // Attempt to find the longest substring match
  foreach ($rdf_namespaces as $prefix => $match) {
    if (strpos($uri, $match) === 0 && strlen($match) > strlen($best_match)) {
      $best_match = $match;
      $best_prefix = $prefix;
    }
  }

  // If successful, life is easy
  if (!empty($best_prefix)) {
    $local_part = substr($uri, strlen($best_match));
    return implode(':', array($best_prefix, $local_part));
  }

  // No existing namespace prefix found, make one up
  if ($gensym && preg_match('@([\w\d-_]+)$@', $uri, $matches)) {
    static $gensym = 0;
    $prefix = 'g.' . ++$gensym; // Good ol' Lisp tradition continues...
    $local_part = $matches[1];
    $rdf_namespaces[$prefix] = substr($uri, 0, -strlen($local_part));
    return implode(':', array($prefix, $local_part));
  }

  //trigger_error('Could not convert URI ' . $uri . ' to QName', E_USER_WARNING);
  return $fail;
}*/

