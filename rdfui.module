<?php
// $Id$

/**
 * @file
 * User interface for RDF.
 */

/**
 * Implements hook_permission().
 */
function rdfui_permission() {
  return array(
    'administer RDF field mappings' => array(
      'title' => t('Change the RDF mappings for types and fields'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function rdfui_menu() {
  $items = array();
  
  // Create tabs for all possible bundles.
  foreach (entity_get_info() as $obj_type => $info) {
    if ($info['fieldable']) {
      foreach ($info['bundles'] as $bundle_name => $bundle_info) {
        if (isset($bundle_info['admin'])) {
          // Extract informations from the bundle description.
          $path = $bundle_info['admin']['path'];
          $bundle_arg = isset($bundle_info['admin']['bundle argument']) ? $bundle_info['admin']['bundle argument'] : $bundle_name;
          $access = array_intersect_key($bundle_info['admin'], drupal_map_assoc(array('access callback', 'access arguments')));
          $instance_position = count(explode('/', $path)) + 1;
          
          $items["$path/rdf"] = array(
            'title' => 'Manage RDF Mappings',
            'load arguments' => array($obj_type, $bundle_arg),
            'page callback' => 'drupal_get_form',
            'page arguments' => array('rdfui_admin_rdf_overview_form', $obj_type, $bundle_arg, $instance_position),
            'type' => MENU_LOCAL_TASK
          ) + $access;        
        }
      }
    }
  }
  
  $items['admin/config/rdfui/datatype/autocomplete'] = array(
    'title' => 'RDF datatype autocomplete',
    'page callback' => 'rdfui_datatype_autocomplete',
    'access arguments' => array('administer RDF field mappings'),
    'type' => MENU_CALLBACK,
  );     
  
  return $items;
}

/**
 * Menu callback; listing of field RDF mappings for a content type.
 *
 * Allows the content type to be mapped to a RDF class and
 * fields to be mapped to RDF properties.
 */
function rdfui_admin_rdf_overview_form($form, &$form_state, $obj_type, $bundle, $instance) {
  
  $form['textfield'] = array(
    '#type' => 'textfield',
    '#title' => 'title'
  );
  
  return $form;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function rdfui_form_field_ui_field_edit_form_alter(&$form, &$form_state) {
  
  $field_name = $form['#field']['field_name'];
  $instance = $form['#fields'][$field_name]['instance'];
  $label = isset($instance['label']) ? $instance['label'] : $instance['field_name'];
  $object_type = $instance['object_type'];
  
  $mapping = rdf_mapping_load($object_type, $instance['bundle']);
  
  $form['rdf'] = array(
    '#type' => 'fieldset',
    '#title' => t('@label RDF Mapping', array('@label' => $label)),
  );
  
  // add the predicate, datatype, etc fields
  rdfui_field_form($form['rdf'], $mapping, $field_name, $label);
  
  $form['submit']['#weight'] = 1;
  
  // add submit and validate handlers
  $form['#validate'] = array_merge($form['#validate'], array('rdfui_form_field_ui_field_edit_form_validate'));
  $form['#submit'] = array_merge($form['#submit'], array('rdfui_form_field_ui_field_edit_form_submit'));
  

}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function rdfui_form_node_type_form_alter(&$form, &$form_state) {
  
  $instance = field_info_instance('node', 'title', $form['#node_type']->type);
  $mapping = rdf_mapping_load($instance['object_type'], $instance['bundle']);
  
  $form['rdf'] = array(
    '#type' => 'fieldset',
    '#title' => 'RDF Title Settings',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#group' => 'additional_settings'
  );
  
  // add the predicate, datatype, etc fields
  rdfui_field_form($form['rdf'], $mapping, 'title', $instance['label']);
  
}

function rdfui_form_field_ui_field_edit_form_validate($form, &$form_state) {
  
  // validate predicates
  if ($predicates = trim($form_state['values']['predicates'])) {
    $predicates = explode("\n",$predicates);
    $pattern = "/^[a-zA-Z0-9]+:[a-zA-Z0-9]+$/";
    $error = '';
    foreach($predicates as $predicate) {
      $predicate = trim($predicate);      
      if (!preg_match($pattern, $predicate)){
        $error .= t('Predicate %predicate is an invalid format. ', array('%predicate'=>$predicate));
      }
    }
    
    if ($error)
      form_set_error('predicates', $error);
  }
  
  // validate datatype
  if ($datatype = trim($form_state['values']['datatype'])) {
    $pattern = "/^[a-zA-Z0-9]+:[a-zA-Z0-9]+$/";
    if(!preg_match($pattern, $datatype))    
      form_set_error('datatype', t('Datatype %datatype is an invalid format.', array('%datatype'=>$datatype)));
  }

}

/**
 * Saves RDF mapping for field.
 */
function rdfui_form_field_ui_field_edit_form_submit($form, &$form_state) {
  $field_name = $form['#field']['field_name'];
  $instance = $form['#fields'][$field_name]['instance'];
  $object_type = $instance['object_type'];
  
  $mapping = rdf_mapping_load($object_type);
  $predicates = explode("\n",$form_state['values']['predicates']);
  $mapping[$field_name]['predicates'] = array_map('trim', $predicates);
  $mapping[$field_name]['datatype'] = $form_state['values']['datatype'];
  $mapping[$field_name]['type'] = $form_state['values']['type'];
  
  $mapping_info = array(
    'mapping' => $mapping,
    'type' => $object_type,
    'bundle' => $instance['bundle']
  );
  
  rdf_mapping_save($mapping_info);
  
}

/**
 * Menu callback for datatype autocomplete
 */
function rdfui_datatype_autocomplete($string) {
  
  $datatypes = 'xsd:string, xsd:boolean, xsd:decimal, xsd:float, xsd:double, xsd:dateTime, xsd:time, xsd:date, xsd:gYearMonth, xsd:gYear, xsd:gMonthDay, xsd:gDay, xsd:gMonth, xsd:hexBinary, xsd:base64Binary, xsd:anyURI, xsd:normalizedString, xsd:token, xsd:language, xsd:NMTOKEN, xsd:Name, xsd:NCName, xsd:integer, xsd:nonPositiveInteger, xsd:negativeInteger, xsd:long, xsd:int, xsd:short, xsd:byte, xsd:nonNegativeInteger, xsd:unsignedLong, xsd:unsignedInt, xsd:unsignedShort, xsd:unsignedByte, xsd:positiveInteger';
  
  $datatypes = explode(', ', $datatypes);
  $matches = array();
  
  foreach($datatypes as $datatype) {
    if (preg_match("/^$string/", $datatype))
      $matches[$datatype] = $datatype;
  }  
  
  drupal_json_output($matches);
}

function rdfui_field_form(&$form, $mapping, $field_name, $label) {
  
  $form['predicates'] = array(
    '#type' => 'textarea',
    '#title' => 'RDF Predicates',
    '#default_value' => empty($mapping[$field_name]['predicates']) ? '' : implode("\n",$mapping[$field_name]['predicates']),
    '#description' => t('Enter the predicate mappings for @label here. Predicates should be listed in CURIE syntax, with the vocabulary namespace and predicate. For example, foaf:name.', array('@label' => $label)),
  );
  
  // @todo Possibly autocomplete the builtin xsd datatypes, but do not restrict to xsd datatypes.
  $form['datatype'] = array(
    '#type' => 'textfield',
    '#title' => 'Datatype',
    '#autocomplete_path' => 'admin/config/rdfui/datatype/autocomplete',
    '#default_value' => empty($mapping[$field_name]['datatype']) ? '' : $mapping[$field_name]['datatype'],
    '#description' => t('If there is a datatype for @label, enter it here. You can use !link or other dataypes.',
      array(
        '@label' => $label,
        '!link' => l('XML Schema datatypes', 'http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#dtype_interp', array('attributes' => array('target' => '_blank'))),
      )
    ),
  );

  $form['type'] = array(
    '#type' => 'select',
    '#title' => 'Attribute Type',
    '#default_value' => empty($mapping[$field_name]['type']) ? 'property' : $mapping[$field_name]['type'],
    '#description' => t('If a field contains a literal, such as a string or an integer, then the property attribute should be used. If it contains a url or node reference, the !rel or !rev attribute should be used.', array('@label' => $label, '!rel' => l('rel','http://www.w3.org/TR/html401/struct/links.html#adef-rel'), '!rev' => l('rev','http://www.w3.org/TR/html401/struct/links.html#adef-rev'))),
    '#options' => array('property'=>'property', 'rel'=>'rel', 'rev'=>'rev'),
  );
  
  
}
 
